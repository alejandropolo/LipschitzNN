Timer unit: 1e-09 s

Total time: 260.065 s
File: /Users/alejandropolo/Library/CloudStorage/OneDrive-UniversidadPontificiaComillas/Escritorio/PhD/Codigo/LipschitzNN/Scripts/utilities_voronoi.py
Function: add_points_to_voronoi at line 600

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   600                                           def add_points_to_voronoi(original_vor, original_points, finite_vor, radius_tot, vertices, distances, 
   601                                                                     model,actfunc, global_lipschitz_constant, x_lim, y_lim,monotone_relations,variable_index,
   602                                                                     n_variables,mode='neuralsens',plot_voronoi=False, epsilon=1e-5, max_iterations=10):
   603                                               """
   604                                               Add points to a Voronoi diagram using the furthest vertex for each point.
   605                                           
   606                                               Args:
   607                                                   original_vor (scipy.spatial.Voronoi): The original Voronoi diagram.
   608                                                   original_points (numpy.ndarray): The original points in the Voronoi diagram.
   609                                                   finite_vor (scipy.spatial.Voronoi): The finite Voronoi diagram (with the added symmetric points)
   610                                                   radius_tot (numpy.ndarray): The radii for each point in the Voronoi diagram.
   611                                                   vertices (numpy.ndarray): The vertices defining the hypercube.
   612                                                   distances (dict): The distances for each point in the Voronoi diagram.
   613                                                   model (torch.nn.Module): The trained model.
   614                                                   global_lipschitz_constant (float): The global Lipschitz constant.
   615                                                   x_lim (tuple): The x-axis limits of the hypercube.
   616                                                   y_lim (tuple): The y-axis limits of the hypercube.
   617                                                   monotone_relations (list): The monotone relations for each variable.
   618                                                   variable_index (list): The indices of the variables to compute the local Lipschitz constant.
   619                                                   n_variables (int): The number of variables.
   620                                                   plot_voronoi (bool, optional): Whether to plot each Voronoi diagram. Defaults to False.
   621                                                   epsilon (float, optional): The extension of the hypercube. Defaults to 1e-5. It is needed to compute symmetric points on the boundary.
   622                                                   max_iterations (int, optional): The maximum number of iterations. Defaults to 10.
   623                                           
   624                                               Returns:
   625                                                   numpy.ndarray: The updated original points in the Voronoi diagram.
   626                                               """
   627                                               ##################################################    ADAPTAR PARA N DIMENSIONES 
   628                                               ## Define the coordinates of the square's vertices
   629         1      18000.0  18000.0      0.0      square_vertices = np.array([[x_lim[0], y_lim[0]], [x_lim[0], y_lim[1]], [x_lim[1], y_lim[1]], [x_lim[1], y_lim[0]], [x_lim[0], y_lim[0]]])
   630                                           
   631                                               ## Generate vertices for a hypercube (n-dimensional cube) defined by the given interval with the given extension
   632         1       3000.0   3000.0      0.0      intervals_extended = [(x_lim[0] - epsilon, x_lim[1] + epsilon), (y_lim[0] - epsilon, y_lim[1] + epsilon)]
   633         1       9000.0   9000.0      0.0      vertices_extended = generate_hypercube_vertices(intervals_extended)
   634                                           
   635                                               ## Boolean warning to print if there are points not following the monotone relation
   636         1          0.0      0.0      0.0      warning = False
   637                                               
   638         1          0.0      0.0      0.0      if mode == 'neuralsens':
   639         1      19000.0  19000.0      0.0          print('Using NeuralSens')
   640         1     202000.0 202000.0      0.0          weights, biases = get_weights_and_biases(model)
   641                                               elif mode == 'autograd':
   642                                                   print('Using autograd')
   643                                               else:
   644                                                   raise ValueError('The mode must be either autograd or neuralsens')
   645                                           
   646      1001     972000.0    971.0      0.0      for i in range(max_iterations):
   647                                                   ## Add new point
   648                                                   #selected_vertex = add_new_point(finite_vor, vertices, distances, radius_tot)
   649      1000        8e+10    8e+07     32.2          selected_vertex = add_new_point_vectorized(finite_vor, vertices, distances, radius_tot)
   650                                                   ## Project the new point to the hypercube (because of the extension it may be outside the hypercube)
   651      1000   43701000.0  43701.0      0.0          selected_vertex = proyection_hypercube(selected_vertex, vertices)
   652                                                   ## Add the new point to the original points
   653      1000   25763000.0  25763.0      0.0          original_points = np.vstack((original_points, selected_vertex))
   654                                                   ## Add the new point to the inputs
   655      1000   46141000.0  46141.0      0.0          inputs = torch.tensor(original_points, dtype=torch.float)
   656                                                   
   657                                                   ## Add the new point to the Voronoi diagram
   658      1000 3953200000.0    4e+06      1.5          original_vor.add_points(selected_vertex.reshape(1, -1))
   659                                                   ## Compute the new finite Voronoi diagram with the new point
   660                                                   ##MODIFICACIÓN PARA NO TENER QUE RECALCULAR EL VORONOI
   661      1000        6e+10    6e+07     22.3          all_points, _ = add_symmetric_points(original_vor, vertices_extended, intervals_extended)
   662      1000 9736418000.0    1e+07      3.7          finite_vor = Voronoi(all_points, incremental=True)
   663                                                   
   664      1000     866000.0    866.0      0.0          """ ## Para intentar evitar recalcular
   665                                                   all_points, symmetric_points = add_symmetric_points(original_vor, vertices_extended, intervals_extended)
   666                                                   ### Check if symmetric points is not an empty array:
   667                                                   print(symmetric_points)
   668                                                   if symmetric_points.shape[0]!=0:        
   669                                                       finite_vor.add_points(np.array(symmetric_points))"""
   670                                           
   671                                                   ## Compute the new radios for each point
   672      1000    1392000.0   1392.0      0.0          if mode=='autograd':
   673                                                       radius_tot, dict_radios, x_reentrenamiento = get_lipschitz_radius(inputs=inputs, model=model, global_lipschitz_constant=global_lipschitz_constant, 
   674                                                                                                                       monotone_relation=monotone_relations, variable_index=variable_index, n_variables=n_variables)
   675      1000     492000.0    492.0      0.0          elif mode=='neuralsens':
   676      2000        6e+10    3e+07     21.8              radius_tot, dict_radios, x_reentrenamiento = get_lipschitz_radius_neuralsens(inputs=inputs, outputs=[], weights=weights, biases=biases, actfunc=actfunc, 
   677      1000     348000.0    348.0      0.0                                                                                          global_lipschitz_constant=global_lipschitz_constant, 
   678      1000     428000.0    428.0      0.0                                                                                          monotone_relation=monotone_relations, variable_index=variable_index, 
   679      1000     220000.0    220.0      0.0                                                                                          n_variables=n_variables)
   680                                           
   681      1000  132720000.0 132720.0      0.1          derivative_sign = [v[1] for _, v in dict_radios.items()]
   682                                                   ## Plot Voronoi diagram
   683      1000     687000.0    687.0      0.0          if plot_voronoi:
   684                                                       plot_finite_voronoi_2D(vor=finite_vor, all_points=all_points, original_points=original_points, radios=radius_tot, boundary=square_vertices, derivative_sign=derivative_sign, plot_symmetric_points=False)
   685                                                   ## Check if the space is filled
   686      1000     989000.0    989.0      0.0          i += 1 ############# CREO QUE DEBERÍA QUITARLO
   687                                                   #space_filled, distances = check_space_filled(finite_vor, radius_tot, vertices)
   688      1000        4e+10    4e+07     15.5          space_filled, distances = check_space_filled_vectorized(finite_vor, radius_tot, vertices)
   689                                                   ## Check if the space is filled and if x_reentrenamiento is empty
   690      1000     725000.0    725.0      0.0          if space_filled and x_reentrenamiento.shape[0]==0:
   691                                                       print('The space is filled: {} after {} iterations '.format(space_filled,i))
   692                                                       break
   693      1000    5891000.0   5891.0      0.0          elif x_reentrenamiento.shape[0]!=0 and not warning:
   694         1      86000.0  86000.0      0.0              print('The retraining set is not empty and therefore the space cannot be filled: {} points'.format(x_reentrenamiento.shape[0]))
   695         1       1000.0   1000.0      0.0              warning = True
   696                                           
   697         1 6956180000.0    7e+09      2.7      plot_finite_voronoi_2D(vor=finite_vor, all_points=all_points, original_points=original_points, radios=radius_tot, boundary=square_vertices, derivative_sign=derivative_sign, plot_symmetric_points=False)